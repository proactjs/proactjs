<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: streams/stream.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: streams/stream.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * &lt;p>
 *  Constructs a ProAct.Stream. The stream is a simple {@link ProAct.Observable}, without state.
 * &lt;/p>
 * &lt;p>
 *  The streams are ment to emit values, events, changes and can be plugged into another observables.
 *  For example you can connect many streams, to merge them and to divide them, to plug them into properties.
 * &lt;/p>
 * &lt;p>
 *  The reactive environment consists of the properties and the objects containing them, but
 *  the outside world is not reactive. It is possible to use the ProAct.Streams as connections from the
 *  outside world to the reactive environment.
 * &lt;/p>
 * &lt;p>
 *    The transformations can be used to change the events or values emitetted.
 * &lt;/p>
 * &lt;p>
 *  ProAct.Stream is part of the streams module of ProAct.js.
 * &lt;/p>
 *
 * @class ProAct.Stream
 * @extends ProAct.Observable
 * @param {ProAct.Observable} source
 *      A default source of the stream, can be null.
 * @param {Array} transforms
 *      A list of transformation to be used on all incoming chages.
 */
ProAct.Stream = ProAct.S = function (source, transforms) {
  P.Observable.call(this, transforms);

  if (source) {
    this.into(source);
  }
};

ProAct.Stream.prototype = P.U.ex(Object.create(P.Observable.prototype), {

  /**
   * Reference to the constructor of this object.
   *
   * @memberof ProAct.Stream
   * @instance
   * @constant
   * @type {Object}
   * @default ProAct.Stream
   */
  constructor: ProAct.Stream,

  /**
   * Creates the &lt;i>event&lt;/i> to be send to the listeners on update.
   * &lt;p>
   *  Streams don't create new events by default, the event is the source.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method makeEvent
   * @param {ProAct.Event} source
   *      The source event of the event. It can be null
   * @return {ProAct.Event}
   *      The event.
   */
  makeEvent: function (source) {
    return source;
  },

  /**
   * Creates the &lt;i>listener&lt;/i> of this stream.
   * &lt;p>
   *  The listener of the stream just calls the method {@link ProAct.Stream#trigger} with the incoming event/value.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method makeListener
   * @return {Object}
   *      The &lt;i>listener of this stream&lt;/i>.
   */
  makeListener: function () {
    if (!this.listener) {
      var stream = this;
      this.listener = function (event) {
        stream.trigger(event, true);
      };
    }

    return this.listener;
  },

  /**
   * Creates the &lt;i>error listener&lt;/i> of this stream.
   * &lt;p>
   *  The listener just calls {@link ProAct.Stream#triggerErr} of &lt;i>this&lt;/i> with the incoming error.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method makeErrListener
   * @return {Object}
   *      The &lt;i>error listener of this stream&lt;/i>.
   */
  makeErrListener: function () {
    if (!this.errListener) {
      var stream = this;
      this.errListener = function (error) {
        stream.triggerErr(error);
      };
    }

    return this.errListener;
  },

  /**
   * Defers a ProAct.Observable listener.
   * &lt;p>
   *  For streams this means pushing it to active flow using {@link ProAct.Flow#push}.
   *  If the listener is object with 'property' field, it is done using {@link ProAct.Observable#defer}.
   *  That way the reactive environment is updated only once, but the streams are not part of it.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method defer
   * @param {Object} event
   *      The event/value to pass to the listener.
   * @param {Object} listener
   *      The listener to defer. It should be a function or object defining the &lt;i>call&lt;/i> method.
   * @return {ProAct.Observable}
   *      &lt;i>this&lt;/i>
   * @see {@link ProAct.Observable#willUpdate}
   * @see {@link ProAct.Observable#makeListener}
   * @see {@link ProAct.flow}
   */
  defer: function (event, listener) {
    if (listener.property) {
      P.Observable.prototype.defer.call(this, event, listener);
      return;
    }

    if (P.U.isFunction(listener)) {
      P.flow.push(listener, [event]);
    } else {
      P.flow.push(listener, listener.call, [event]);
    }
  },

  /**
   * &lt;p>
   *  Triggers a new event/value to the stream. Anything that is listening for events from
   *  this stream will get updated.
   * &lt;/p>
   * &lt;p>
   *  ProAct.Stream.t is alias of this method.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method trigger
   * @param {Object} event
   *      The event/value to pass to trigger.
   * @param {Boolean} useTransformations
   *      If the stream should transform the triggered value. By default it is true (if not passed)
   * @return {ProAct.Stream}
   *      &lt;i>this&lt;/i>
   * @see {@link ProAct.Observable#update}
   */
  trigger: function (event, useTransformations) {
    if (useTransformations === undefined) {
      useTransformations = true;
    }

    return this.go(event, useTransformations);
  },

  /**
   * &lt;p>
   *  Triggers all the passed params, using transformations.
   * &lt;/p>
   * &lt;p>
   *  ProAct.Stream.tt is alias of this method.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method triggerMany
   * @param [...]
   *      A list of events/values to trigger
   * @return {ProAct.Stream}
   *      &lt;i>this&lt;/i>
   * @see {@link ProAct.Stream#trigger}
   */
  triggerMany: function () {
    var i, args = slice.call(arguments), ln = args.length;

    for (i = 0; i &lt; ln; i++) {
      this.trigger(args[i], true);
    }

    return this;
  },

  /**
   * &lt;p>
   *  Triggers a new error to the stream. Anything that is listening for errors from
   *  this stream will get updated.
   * &lt;/p>
   * &lt;p>
   *  ProAct.Stream.te is alias of this method.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method triggerErr
   * @param {Error} err
   *      The error to trigger.
   * @return {ProAct.Observable}
   *      &lt;i>this&lt;/i>
   * @see {@link ProAct.Observable#update}
   */
  triggerErr: function (err) {
    return this.update(err, 'error');
  },

  // private
  go: function (event, useTransformations) {
    var i, tr = this.transforms, ln = tr.length;

    if (useTransformations) {
      try {
        event = P.Observable.transform(this, event);
      } catch (e) {
        this.triggerErr(e);
        return this;
      }
    }

    if (event === P.Observable.BadValue) {
      return this;
    }

    return this.update(event);
  },

  /**
   * Creates a new ProAct.Stream instance with source &lt;i>this&lt;/i> and mapping
   * the passed &lt;i>mapping function&lt;/i>.
   *
   * @memberof ProAct.Stream
   * @instance
   * @method map
   * @param {Object} mappingFunction
   *      Function or object with a &lt;i>call method&lt;/i> to use as map function.
   * @return {ProAct.Stream}
   *      A new ProAct.Stream instance with the &lt;i>mapping&lt;/i> applied.
   * @see {@link ProAct.Observable#mapping}
   */
  map: function (mappingFunction) {
    return new P.S(this).mapping(mappingFunction);
  },

  /**
   * Creates a new ProAct.Stream instance with source &lt;i>this&lt;/i> and filtering
   * the passed &lt;i>filtering function&lt;/i>.
   *
   * @memberof ProAct.Stream
   * @instance
   * @method filter
   * @param {Object} filteringFunction
   *      The filtering function or object with a call method, should return boolean.
   * @return {ProAct.Stream}
   *      A new ProAct.Stream instance with the &lt;i>filtering&lt;/i> applied.
   * @see {@link ProAct.Observable#filtering}
   */
  filter: function (filteringFunction) {
    return new P.S(this).filtering(filteringFunction);
  },

  /**
   * Creates a new ProAct.Stream instance with source &lt;i>this&lt;/i> and accumulation
   * the passed &lt;i>accumulation function&lt;/i>.
   *
   * @memberof ProAct.Stream
   * @instance
   * @method accumulate
   * @param {Object} initVal
   *      Initial value for the accumulation. For example '0' for sum.
   * @param {Object} accumulationFunction
   *      The function to accumulate.
   * @return {ProAct.Stream}
   *      A new ProAct.Stream instance with the &lt;i>accumulation&lt;/i> applied.
   * @see {@link ProAct.Observable#accumulation}
   */
  accumulate: function (initVal, accumulationFunction) {
    return new P.S(this).accumulation(initVal, accumulationFunction);
  },

  /**
   * Creates a new ProAct.Stream instance that merges this with other streams.
   * The new instance will have new value on value from any of the source streams.
   *
   * @memberof ProAct.Stream
   * @instance
   * @method merge
   * @param [...]
   *      A list of streams to be set as sources.
   * @return {ProAct.Stream}
   *      A new ProAct.Stream instance with the sources this and all the passed streams.
   */
  merge: function () {
    var sources = [this].concat(slice.call(arguments)),
        result = new P.S();

    return P.S.prototype.into.apply(result, sources);
  }
});

P.U.ex(P.F.prototype, {

  /**
   * Retrieves the errStream for logging errors from this flow.
   * If there is no error stream, it is created.
   *
   * @memberof ProAct.Flow
   * @instance
   * @method errStream
   * @return {ProAct.Stream}
   *      The error stream of the flow.
   */
  errStream: function () {
    if (!this.errStreamVar) {
      this.errStreamVar = new P.S();
    }

    return this.errStreamVar;
  }
});

P.S.prototype.t = P.S.prototype.trigger;
P.S.prototype.tt = P.S.prototype.triggerMany;
P.S.prototype.te = P.S.prototype.triggerErr;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ProAct.Array.html">Array</a></li><li><a href="ProAct.ArrayCore.html">ArrayCore</a></li><li><a href="ProAct.ArrayProperty.html">ArrayProperty</a></li><li><a href="ProAct.AutoProperty.html">AutoProperty</a></li><li><a href="ProAct.BufferedStream.html">BufferedStream</a></li><li><a href="ProAct.Core.html">Core</a></li><li><a href="ProAct.DebouncingStream.html">DebouncingStream</a></li><li><a href="ProAct.DelayedStream.html">DelayedStream</a></li><li><a href="ProAct.Event.html">Event</a></li><li><a href="ProAct.Flow.html">Flow</a></li><li><a href="ProAct.NullProperty.html">NullProperty</a></li><li><a href="ProAct.ObjectCore.html">ObjectCore</a></li><li><a href="ProAct.ObjectProperty.html">ObjectProperty</a></li><li><a href="ProAct.Observable.html">Observable</a></li><li><a href="ProAct.Property.html">Property</a></li><li><a href="ProAct.Queue.html">Queue</a></li><li><a href="ProAct.Queues.html">Queues</a></li><li><a href="ProAct.SizeBufferedStream.html">SizeBufferedStream</a></li><li><a href="ProAct.Stream.html">Stream</a></li><li><a href="ProAct.ThrottlingStream.html">ThrottlingStream</a></li></ul><h3>Namespaces</h3><ul><li><a href="ProAct.html">ProAct</a></li><li><a href="ProAct.Array.Listeners.html">Listeners</a></li><li><a href="ProAct.Array.Operations.html">Operations</a></li><li><a href="ProAct.Configuration.html">Configuration</a></li><li><a href="ProAct.Event.Types.html">Types</a></li><li><a href="ProAct.Property.Types.html">Types</a></li><li><a href="ProAct.States.html">States</a></li><li><a href="ProAct.Utils.html">Utils</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Wed Jul 30 2014 09:34:05 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
