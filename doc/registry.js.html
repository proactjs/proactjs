<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: registry/registry.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: registry/registry.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * &lt;p>
 *  Constructs a ProAct.Registry. It is used to store/create objects that can be referenced or configured using the {@link ProAct.DSL}.
 * &lt;/p>
 * &lt;p>
 *  ProAct.Registry is part og the DSL module of ProAct.js.
 * &lt;/p>
 *
 * @class ProAct.Registry
 */
ProAct.Registry = P.R = function () {
  this.providers = {};
};

ProAct.Registry.prototype = rProto = {

  /**
   * Reference to the constructor of this object.
   *
   * @memberof ProAct.Registry
   * @instance
   * @constant
   * @default ProAct.Registry
   */
  constructor: ProAct.Registry,

  /**
   * Registers a {@link ProAct.Registry.Provider} for the passed &lt;i>namespace&lt;/i> in the registry.
   *
   * @memberof ProAct.Registry
   * @instance
   * @method register
   * @param {String} namespace
   *      The namespace to register the &lt;i>provider&lt;/i> in.
   * @param {ProAct.Registry.Provider} provider
   *      The {@link ProAct.Registry.Provider} to register.
   * @return {ProAct.Registers}
   *      &lt;i>this&lt;/i>
   * @throws {Error}
   *      If a {@link ProAct.Registry.Provider} is already registered for the passed &lt;i>namespace&lt;/i>.
   * @see {@link ProAct.Registry.Provider}
   */
  register: function (namespace, provider) {
    if (this.providers[namespace]) {
      throw new Error(namespace + 'is already registered in this registry.');
    }
    this.providers[namespace] = provider;
    if (provider.registered) {
      provider.registered(this);
    }
    return this;
  },

  /**
   * Retrieves the right {@link ProAct.Registry.Provider} using the &lt;i>name&lt;/i> of stored
   * in &lt;i>this&lt;/i> ProAct.Registry object, or the &lt;i>name&lt;/i> of an object to be stored
   *
   * @memberof ProAct.Registry
   * @instance
   * @method getProviderByName
   * @param {String} name
   *      The name of storable object.
   *      &lt;p>
   *        It must be in the format '{namespace}:{key}'.
   *      &lt;/p>
   *      &lt;p>
   *        Here the namespace is the namespace the {@link ProAct.Registry.Provider} manages.
   *      &lt;/p>
   * @return {Array}
   *      The first element in the result is the {@link ProAct.Registry.Provider} or undefined if not found.
   *      &lt;p>
   *        The second one is the &lt;b>key&lt;/b> at which an object is stored or will be stored in the provider.
   *      &lt;/p>
   *      &lt;p>
   *        The third element is an array with options for storing/creating an object passed to the provider using
   *        the &lt;i>name&lt;/i> string.
   *      &lt;/p>
   * @see {@link ProAct.Registry.Provider}
   */
  getProviderByName: function (name) {
    var parts = name.split(':');

    return [this.providers[parts[0]], parts[1], parts.slice(2)];
  },

  /**
   * Configures an object to be stored using {@link ProAct.DSL} passed through &lt;i>options&lt;/i> and DSL arguments.
   * &lt;p>
   *  Example usage:
   * &lt;/p>
   * &lt;p>
   *  A {@link ProAct.Stream} is passed to the registry for setup with DSL data.
   * &lt;/p>
   * &lt;p>
   *  The data passed through the &lt;i>options&lt;/i> parameter is
   *  &lt;pre>
   *    '&lt;&lt;(s:foo)|map(-)|filter($1)'
   *  &lt;/pre>
   * &lt;/p>
   * &lt;p>
   *  And the arguments for the DSL machine passed through the &lt;i>args&lt;/i> parameter are
   *  &lt;pre>
   *    [function (v) {
   *      return v % 2 === 0;
   *    }]
   *  &lt;/pre>
   * &lt;/p>
   * &lt;p>
   *  This means that a {@link ProAct.Stream} stored in &lt;i>this&lt;/i> registry by the key 'foo' should be set
   *  as a source to the passed as the &lt;i>object&lt;/i> parameter simple {@link ProAct.Stream}.
   * &lt;/p>
   * &lt;p>
   *  It also means that for every value comming in the &lt;i>object&lt;/i> parameter's stream there should be mapping of negativity and
   *  only even values should be passed to it.
   * &lt;/p>
   * &lt;p>
   *  So if we trigger in the 'foo' stream the value of &lt;b>4&lt;/b> in our stream we will get &lt;b>-4&lt;/b>, and if we trigger 5, we won't get anything.
   * &lt;/p>
   *
   * @memberof ProAct.Registry
   * @instance
   * @method setup
   * @param {Object} object
   *      The object to setup.
   * @param {String|Object} options
   *      A {@link ProAct.DSL} data object or string used to setup the object.
   * @param {Array} args
   *      Arguments to be used by the {@link ProAct.DSL#run} method while configuring the passed &lt;i>object&lt;/i>.
   * @return {Object}
   *      Ready to strore object.
   * @see {@link ProAct.DSL}
   * @see {@link ProAct.DSL#run}
   */
  setup: function (object, options, args) {
    return dsl.run.apply(null, [object, options, this].concat(args));
  },

  /**
   * Creates a new object and stores it in &lt;i>this&lt;/i> registry, using the right provider for the creation
   * and configuring it using the DSL passed through the &lt;i>options&lt;/i> parameter.
   * &lt;p>
   *  {@link ProAct.Registry#getProviderByName} is used to locate the right provider to create the object with.
   * &lt;/p>
   * &lt;p>
   *  {@link ProAct.Registry#setup} is used to setup the newly created object using the {@link ProAct.DSL}
   * &lt;/p>
   * &lt;p>
   *  The idea of this method is to create and configure {@link ProAct.Observable} objects.
   * &lt;/p>
   *
   * @memberof ProAct.Registry
   * @instance
   * @method make
   * @param {String} name
   *      Name of the object to create and store.
   *      &lt;p>
   *        It must be in the format '{namespace}:{key}'
   *      &lt;/p>
   * @param {String|Object} options
   *      A {@link ProAct.DSL} data object or string used to setup the object to be created.
   * @param [...]
   *      &lt;b>Arguments&lt;/b> to be used by the {@link ProAct.DSL#run} method while configuring the newly created &lt;i>object&lt;/i>.
   * @return {Object}
   *      The newly created, stored and configured object, or null if there was no {@link ProAct.Registry.Provider} register for its type.
   * @see {@link ProAct.DSL}
   * @see {@link ProAct.Registry#getProviderByName}
   * @see {@link ProAct.Registry#setup}
   * @see {@link ProAct.Observable}
   */
  make: function (name, options) {
    var args = slice.call(arguments, 2),
        p = this.getProviderByName(name),
        observable;

    if (p[0]) {
      observable = p[0].make.apply(p[0], [p[1], p[2]].concat(args));
      return this.setup(observable, options, args);
    }
    return null;
  },

  /**
   * Stores an object  in &lt;i>this&lt;/i> registry, using the right provider to configure it using the DSL passed through the &lt;i>options&lt;/i> parameter.
   * &lt;p>
   *  {@link ProAct.Registry#getProviderByName} is used to locate the right provider to store the object to.
   * &lt;/p>
   *
   * @memberof ProAct.Registry
   * @instance
   * @method store
   * @param {String} name
   *      Name of the object to store.
   *      &lt;p>
   *        It must be in the format '{namespace}:{key}'
   *      &lt;/p>
   * @param {Object} object
   *      The object to store.
   * @param {String|Object} options
   *      A {@link ProAct.DSL} data object or string used to setup the object to be stored (optional).
   * @param [...]
   *      &lt;b>Arguments&lt;/b> to be used by the {@link ProAct.DSL#run} method while configuring the &lt;i>object&lt;/i>.
   * @return {Object}
   *      The stored and configured object, or null if there was no {@link ProAct.Registry.Provider} register for its type.
   * @see {@link ProAct.DSL}
   * @see {@link ProAct.Registry#getProviderByName}
   */
  store: function (name, object, options) {
    var args = slice.call(arguments, 2),
        p = this.getProviderByName(name);

    if (p[0]) {
      return p[0].store.apply(p[0], [p[1], object, p[2]].concat(args));
    }
    return null;
  },

  /**
   * Retrieves an object, stored &lt;i>this&lt;/i> registry.
   * &lt;p>
   *  {@link ProAct.Registry#getProviderByName} is used to locate the right provider to retrieve the object from.
   * &lt;/p>
   *
   * @memberof ProAct.Registry
   * @instance
   * @method get
   * @param {String} name
   *      Name of the object to find.
   *      &lt;p>
   *        It must be in the format '{namespace}:{key}'
   *      &lt;/p>
   * @return {Object}
   *      The stored object, or null if there was no {@link ProAct.Registry.Provider} register for its type or no object registered for the passed &lt;i>name&lt;/i>.
   * @see {@link ProAct.Registry#getProviderByName}
   */
  get: function (name) {
    var p = this.getProviderByName(name);

    if (p[0]) {
      return p[0].get(p[1]);
    }
    return null;
  },

  /**
   * Helper method for transforming an array of keys of stored items in &lt;i>this&lt;/i> ProAct.Registry to an array of the actual items.
   * &lt;p>
   *  Mainly used by the {@link ProAct.DSL} logic.
   * &lt;/p>
   *
   * @memberof ProAct.Registry
   * @instance
   * @method toObjectArray
   * @param {Array} array
   *      Array of string keys to objects stored in &lt;i>this&lt;/i> registry to be retrieved using {@link ProAct.Registry#toObject}.
   *      &lt;p>
   *        If object is not stored on some key, the key itself is returned in the same possition in the result array.
   *      &lt;/p>
   * @return {Array}
   *      Of the retrieved objects, in the same order as the keys.
   * @see {@link ProAct.Registry#toObject}
   * @see {@link ProAct.DSL}
   */
  toObjectArray: function (array) {
    var self = this;
    if (!P.U.isArray(array)) {
      return this.toObject(array);
    }
    return map.call(array, function (el) {
      return self.toObject(el);
    });
  },

  /**
   * Helper method for transforming a key of stored item in &lt;i>this&lt;/i> ProAct.Registry to the actual item or returning the key, if
   * the item is not found in the ProAct.Registry.
   * &lt;p>
   *  Mainly used by the {@link ProAct.DSL} logic.
   * &lt;/p>
   *
   * @memberof ProAct.Registry
   * @instance
   * @method toObject
   * @param {String|Object} data
   *      Key of strored object or something else. If the key is valid and there is something stored on it, the stored object is retrieved.
   *      &lt;p>
   *        If there is nothing stored for this &lt;i>data&lt;/i>, the &lt;i>data&lt;/i> itself is returned.
   *      &lt;/p>
   * @return {Object}
   *      Stored object, if found using the passed &lt;i>data&lt;/i> or the &lt;i>data&lt;/i> itself.
   * @see {@link ProAct.DSL}
   * @see {@link ProAct.Registry#get}
   */
  toObject: function (data) {
    if (P.U.isString(data)) {
      var result = this.get(data);
      return result ? result : data;
    }

    return data;
  }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ProAct.Array.html">Array</a></li><li><a href="ProAct.ArrayCore.html">ArrayCore</a></li><li><a href="ProAct.ArrayProperty.html">ArrayProperty</a></li><li><a href="ProAct.AutoProperty.html">AutoProperty</a></li><li><a href="ProAct.BufferedStream.html">BufferedStream</a></li><li><a href="ProAct.Core.html">Core</a></li><li><a href="ProAct.DebouncingStream.html">DebouncingStream</a></li><li><a href="ProAct.DelayedStream.html">DelayedStream</a></li><li><a href="ProAct.Event.html">Event</a></li><li><a href="ProAct.Flow.html">Flow</a></li><li><a href="ProAct.NullProperty.html">NullProperty</a></li><li><a href="ProAct.ObjectCore.html">ObjectCore</a></li><li><a href="ProAct.ObjectProperty.html">ObjectProperty</a></li><li><a href="ProAct.Observable.html">Observable</a></li><li><a href="ProAct.Property.html">Property</a></li><li><a href="ProAct.Queue.html">Queue</a></li><li><a href="ProAct.Queues.html">Queues</a></li><li><a href="ProAct.Registry.html">Registry</a></li><li><a href="ProAct.SizeBufferedStream.html">SizeBufferedStream</a></li><li><a href="ProAct.Stream.html">Stream</a></li><li><a href="ProAct.ThrottlingStream.html">ThrottlingStream</a></li><li><a href="ProAct.Val.html">Val</a></li></ul><h3>Namespaces</h3><ul><li><a href="ProAct.html">ProAct</a></li><li><a href="ProAct.Array.Listeners.html">Listeners</a></li><li><a href="ProAct.Array.Operations.html">Operations</a></li><li><a href="ProAct.Configuration.html">Configuration</a></li><li><a href="ProAct.Event.Types.html">Types</a></li><li><a href="ProAct.Property.Types.html">Types</a></li><li><a href="ProAct.States.html">States</a></li><li><a href="ProAct.Utils.html">Utils</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Wed Jul 30 2014 18:16:47 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
