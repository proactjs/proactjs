<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: properties/property.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: properties/property.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * &lt;p>
 *  Constructs a ProAct.Property. The properties are simple {@link ProAct.Observable}s with state. The basic property
 *  has a state of a simple value - number/string/boolean.
 * &lt;/p>
 * &lt;p>
 *  Every property represents a field in a plain javascript object. It makes it reactive, on reading the property value,
 *  if {@link ProAct.currentCaller} is set, it is added as a listener to the property changes.
 * &lt;/p>
 * &lt;p>
 *  Every property has a type the default property has a type of a simple value.
 * &lt;/p>
 * &lt;p>
 *  All the properties of an object are managed by its {@link ProAct.ObjectCore}, which is set to a hidden field of the object - '__pro__'.
 * &lt;/p>
 * &lt;p>
 *  When created every property is in {@link ProAct.States.init} state, when it is functional, the state is changed to {@link ProAct.States.ready}.
 *  If the property is not in {@link ProAct.States.ready} state, it is not useable.
 * &lt;/p>
 * &lt;p>
 *  {@link ProAct.Property#init} is called by this constructor for the property initialization. It should initialize the property and set its state to {@link ProAct.States.ready}.
 * &lt;/p>
 * &lt;p>
 *  ProAct.Property is part of the properties module of ProAct.js.
 * &lt;/p>
 *
 * @class ProAct.Property
 * @extends ProAct.Observable
 * @param {Object} proObject
 *      A plain JavaScript object, holding a field, this property will represent.
 * @param {String} property
 *      The name of the field of the object, this property should represent.
 * @param {Function} getter
 *      An optional getter to be used when the property is read. If this parameter is empty, a new {@link ProAct.Property.defaultGetter} is build for &lt;i>this&lt;/i>.
 * @param {Function} setter
 *      An optional setter to be used when the property is written. If this parameter is empty, a new {@link ProAct.Property.defaultSetter} is build for &lt;i>this&lt;/i>.
 * @see {@link ProAct.ObjectCore}
 * @see {@link ProAct.Property.defaultGetter}
 * @see {@link ProAct.Property.defaultSetter}
 * @see {@link ProAct.Property#init}
 * @see {@link ProAct.States.init}
 * @see {@link ProAct.States.ready}
 */
ProAct.Property = P.P = function (proObject, property, getter, setter) {
  P.U.defValProp(this, 'proObject', false, false, true, proObject);
  this.property = property;

  if (!this.proObject.__pro__) {
    P.U.defValProp(proObject, '__pro__', false, false, true, new ProAct.ObjectCore(proObject));
  }

  this.proObject.__pro__.properties[property] = this;

  this.get = getter || P.P.defaultGetter(this);
  this.set = setter || P.P.defaultSetter(this);

  this.oldVal = null;
  this.val = proObject[property];

  this.state = P.States.init;
  this.g = this.get;
  this.s = this.set;

  P.Observable.call(this); // Super!
  this.parent = this.proObject.__pro__;

  this.init();
};

P.U.ex(ProAct.Property, {

  /**
   * Defines the possible types of the ProAct.Property.
   *
   * @namespace ProAct.Property.Types
   */
  Types: {

    /**
     * ProAct.Property for simple types - Numbers, Strings or Booleans.
     *
     * @memberof ProAct.Property.Types
     * @static
     * @constant
     */
    simple: 0, // strings, booleans and numbers

    /**
     * ProAct.Property for auto computed types - Functions.
     *
     * @memberof ProAct.Property.Types
     * @static
     * @constant
     */
    auto: 1, // functions - dependent

    /**
     * ProAct.Property for object types - fields containing objects.
     *
     * @memberof ProAct.Property.Types
     * @static
     * @constant
     */
    object: 2, // references Pro objects

    /**
     * ProAct.Property for array types - fields containing arrays.
     *
     * @memberof ProAct.Property.Types
     * @static
     * @constant
     */
    array: 3, // arrays

    /**
     * ProAct.Property for nil types - fields containing null or undefined.
     *
     * @memberof ProAct.Property.Types
     * @static
     * @constant
     */
    nil: 4, // nulls

    /**
     * Retrieves the right ProAct.Property.Types value from a value.
     *
     * @memberof ProAct.Property.Types
     * @static
     * @param {Object} value
     *      The value to use to compute the ProAct.Property.Types member for.
     * @return {Number}
     *      The type of the passed value.
     */
    type: function (value) {
      if (value === null) {
        return P.P.Types.nil;
      } else if (P.U.isFunction(value)) {
        return P.P.Types.auto;
      } else if (P.U.isArray(value)) {
        return P.P.Types.array;
      } else if (P.U.isObject(value)) {
        return P.P.Types.object;
      } else {
        return P.P.Types.simple;
      }
    }
  },

  /**
   * Generates a default getter function for a ProAct.Property instance.
   * &lt;p>
   *  Every ProAct.Property instance has a getter and a setter, they can be passed in the constructor, but if left blank,
   *  this method is used for creating the getter function.
   * &lt;/p>
   * &lt;p>
   *  The default getter function uses {@link ProAct.Property#addCaller} method to track the {@link ProAct.currentCaller} listener if set.
   *  If it is set it is added as a listener to the passed &lt;i>property&lt;/i>.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @static
   * @param {ProAct.Property} property
   *      The ProAct.Property instance to generate a getter function for.
   * @return {Function}
   *      The generated getter function.
   */
  defaultGetter: function (property) {
    return function () {
      property.addCaller();

      return property.val;
    };
  },

  /**
   * Generates a default setter function for a ProAct.Property instance.
   * &lt;p>
   *  Every ProAct.Property instance has a setter and a getter, they can be passed in the constructor, but if left blank,
   *  this method is used for creating the setter function.
   * &lt;/p>
   * &lt;p>
   *  The default setter function uses {@link ProAct.Property#update} method to update all the listeners for &lt;i>change&lt;/i>s for the passed
   *  &lt;i>property&lt;/i>.
   * &lt;/p>
   * &lt;p>
   *  It updates the listeners only if the new value of the property is different from the old one (using &lt;i>===&lt;/i> for the comparison).
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @static
   * @param {ProAct.Property} property
   *      The ProAct.Property instance to generate a setter function for.
   * @param {Function} setter
   *      A setter function for the way of setting the value. It can be skipped if the value should be set using &lt;i>=&lt;/i>.
   * @return {Function}
   *      The generated setter function.
   */
  defaultSetter: function (property, setter) {
    return function (newVal) {
      if (property.val === newVal) {
        return;
      }

      property.oldVal = property.val;
      if (setter) {
        property.val = setter.call(property.proObject, newVal);
      } else {
        property.val = P.Observable.transform(property, newVal);
      }

      if (property.val === null || property.val === undefined) {
        P.P.reProb(property).update();
        return;
      }

      property.update();
    };
  },

  /**
   * Used to define the managed by a ProAct.Property instance field of the passed &lt;i>obj&lt;/i>.
   * &lt;p>
   *  The field is writable, enumerable and configurable.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @static
   * @param {Object} obj
   *      The object which field should be defined as a property.
   * @param {String} prop
   *      The name of the property field to define.
   * @param {Function} get
   *      The getter that should be used to read the new property to be defined.
   * @param {Function} set
   *      The setter that should be used to update the new property to be defined.
   */
  defineProp: function (obj, prop, get, set) {
    Object.defineProperty(obj, prop, {
      get: get,
      set: set,
      enumerable: true,
      configurable: true
    });
  },

  /**
   * Recreates a property, using its current value.
   * &lt;p>
   *  For example if the initial value of the field was null, the property can be set to be instance of {@link ProAct.NullProperty},
   *  but if it changes to the number &lt;i>3&lt;/i> it can be changed to {@link ProAct.Property} using this method.
   * &lt;/p>
   * &lt;p>
   *  The re-definition works by using {@link ProAct.Property#destroy} to destroy the passed &lt;i>property&lt;/i> first, and then the
   *  {@link ProAct.ObjectCore#makeProp} method is called of the {@link ProAct.ObjectCore} of the object the &lt;i>property&lt;/i> belongs to.
   * &lt;/p>
   * &lt;p>
   *  This way a new ProAct.Property instance is created to replace the passed one.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @static
   * @param {ProAct.Property} property
   *      The ProAct.Property instance to re-define.
   * @return {ProAct.Property}
   *      The new re-defined property.
   */
  reProb: function (property) {
    var po = property.proObject,
        p = property.property,
        l = property.listeners.change;

    property.destroy();
    return po.__pro__.makeProp(p, l);
  }
});

ProAct.Property.prototype = P.U.ex(Object.create(P.Observable.prototype), {

  /**
   * Reference to the constructor of this object.
   *
   * @memberof ProAct.Property
   * @instance
   * @constant
   * @default ProAct.Property
   */
  constructor: ProAct.Property,

  /**
   * Retrieves the {@link ProAct.Property.Types} value of &lt;i>this&lt;/i> property.
   * &lt;p>
   *  For instances of the base class - ProAct.Property it is {@link ProAct.Property.Types.simple}.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method type
   * @return {Number}
   *      The right type of the property.
   */
  type: function () {
    return P.P.Types.simple;
  },

  /**
   * Creates the &lt;i>event&lt;/i> to be send to the listeners of this ProAct.Property on update.
   * &lt;p>
   *  The &lt;i>event&lt;/i> should be an instance of {@link ProAct.Event}.
   * &lt;/p>
   * &lt;p>
   *  By default this method returns {@link ProAct.Event.Types.value} event with target the property name and arguments:
   *  &lt;ul>
   *    &lt;li>The object this ProAct.Property manages a field for.&lt;/li>
   *    &lt;li>The old value of this property.&lt;/li>
   *    &lt;li>The new value of this property.&lt;/li>
   *  &lt;/ul>
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method makeEvent
   * @default {ProAct.Event} with type {@link ProAct.Event.Types.value}
   * @param {ProAct.Event} source
   *      The source event of the event. It can be null
   * @return {ProAct.Event}
   *      The event, created.
   */
  makeEvent: function (source) {
    return new P.E(source, this.property, P.E.Types.value, this.proObject, this.oldVal, this.val);
  },

  /**
   * Creates the &lt;i>listener&lt;/i> of this ProAct.Property.
   * &lt;p>
   *  This listener turns the observable in a observer.
   * &lt;/p>
   * &lt;p>
   *  The listener for ProAct.Property is an object defining the &lt;i>call&lt;/i> method.
   * &lt;/p>
   * &lt;p>
   *  It has a &lt;i>property&lt;/i> field set to &lt;i>this&lt;/i>.
   * &lt;/p>
   * &lt;p>
   *  On value changes the &lt;i>&lt;this&lt;/i> value is set to the new value using the {@link ProAct.Observable#transform} to transform it.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method makeListener
   * @return {Object}
   *      The &lt;i>listener of this ProAct.Property&lt;/i>.
   */
  makeListener: function () {
    if (!this.listener) {
      var self = this;

      this.listener = {
        property: self,
        call: function (newVal) {
          if (newVal && newVal.type !== undefined && newVal.type === P.E.Types.value && newVal.args.length === 3 && newVal.target) {
            newVal = newVal.args[0][newVal.target];
          }

          self.oldVal = self.val;
          self.val = P.Observable.transform(self, newVal);
        }
      };
    }

    return this.listener;
  },

  /**
   * Initializes this property.
   * &lt;p>
   *  This method logic is run only if the current state of &lt;i>this&lt;/i> is {@link ProAct.States.init}.
   * &lt;/p>
   * &lt;p>
   *  First the property is defined as a field in its object, using {@link ProAct.Property.defineProp}.
   * &lt;/p>
   * &lt;p>
   *  Then {@link ProAct.Property#afterInit} is called to finish the initialization.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method init
   * @see {@link ProAct.Property#afterInit}
   */
  init: function () {
    if (this.state !== P.States.init) {
      return;
    }

    P.P.defineProp(this.proObject, this.property, this.get, this.set);

    this.afterInit();
  },

  /**
   * Called automatically after initialization of this property.
   * &lt;p>
   *  By default it changes the state of &lt;i>this&lt;/i> to {@link ProAct.States.ready}.
   * &lt;/p>
   * &lt;p>
   *  It can be overridden to define more complex initialization logic.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method afterInit
   */
  afterInit: function () {
    this.state = P.States.ready;
  },

  /**
   * Uses {@link ProAct.currentCaller} to automatically add a new listener to this property if the caller is set.
   * &lt;p>
   *  This method is used by the default getter to make every reader of the property a listener to it.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method addCaller
   */
  addCaller: function () {
    var caller = P.currentCaller;

    if (caller && caller.property !== this) {
      this.on(caller);
    }
  },

  /**
   * Destroys this ProAct.Property instance, by making the field it manages to a normal field.
   * &lt;p>
   *  The state of &lt;i>this&lt;/i> is set to {@link ProAct.States.destroyed}.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method destroy
   */
  destroy: function () {
    if (this.state === P.States.destroyed) {
      return;
    }

    delete this.proObject.__pro__.properties[this.property];
    this.listeners = undefined;
    this.oldVal = undefined;
    this.parent = undefined;

    P.U.defValProp(this.proObject, this.property, true, true, true, this.val);
    this.get = this.set = this.property = this.proObject = undefined;
    this.g = this.s = undefined;
    this.val = undefined;
    this.state = P.States.destroyed;
  },

  /**
   * The &lt;b>toString()&lt;/b> method returns a string representing this ProAct.Property.
   * &lt;p>
   *  The string representation is the value of &lt;i>this&lt;/i> property.
   * &lt;/p>
   *
   * @memberof ProAct.Property
   * @instance
   * @method toString
   */
  toString: function () {
    return this.val;
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ProAct.Array.html">Array</a></li><li><a href="ProAct.ArrayCore.html">ArrayCore</a></li><li><a href="ProAct.ArrayProperty.html">ArrayProperty</a></li><li><a href="ProAct.AutoProperty.html">AutoProperty</a></li><li><a href="ProAct.BufferedStream.html">BufferedStream</a></li><li><a href="ProAct.Core.html">Core</a></li><li><a href="ProAct.DebouncingStream.html">DebouncingStream</a></li><li><a href="ProAct.DelayedStream.html">DelayedStream</a></li><li><a href="ProAct.Event.html">Event</a></li><li><a href="ProAct.Flow.html">Flow</a></li><li><a href="ProAct.NullProperty.html">NullProperty</a></li><li><a href="ProAct.ObjectCore.html">ObjectCore</a></li><li><a href="ProAct.ObjectProperty.html">ObjectProperty</a></li><li><a href="ProAct.Observable.html">Observable</a></li><li><a href="ProAct.Property.html">Property</a></li><li><a href="ProAct.Queue.html">Queue</a></li><li><a href="ProAct.Queues.html">Queues</a></li><li><a href="ProAct.SizeBufferedStream.html">SizeBufferedStream</a></li><li><a href="ProAct.Stream.html">Stream</a></li><li><a href="ProAct.ThrottlingStream.html">ThrottlingStream</a></li><li><a href="ProAct.Val.html">Val</a></li></ul><h3>Namespaces</h3><ul><li><a href="ProAct.html">ProAct</a></li><li><a href="ProAct.Array.Listeners.html">Listeners</a></li><li><a href="ProAct.Array.Operations.html">Operations</a></li><li><a href="ProAct.Configuration.html">Configuration</a></li><li><a href="ProAct.Event.Types.html">Types</a></li><li><a href="ProAct.Property.Types.html">Types</a></li><li><a href="ProAct.States.html">States</a></li><li><a href="ProAct.Utils.html">Utils</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Wed Jul 30 2014 13:28:45 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
